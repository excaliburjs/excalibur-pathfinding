class ExcaliburGraph{data;isLoaded(){return!0}load(){return Promise.resolve()}key=!1;nodes=new Map;edges=new Map;addNode(e){this.nodes.set(e.name,e)}addEdge(e,t=!1){this.edges.set(e.name,e),t&&(t={name:e.name+"_reverse",from:e.to,to:e.from},e.value&&Object.assign(t,{value:e.value}),this.addEdge(t))}resetGraph(){this.nodes=new Map,this.edges=new Map}addTileMap(d){d.tiles.forEach((e,t)=>{e.collider||this.addNode({name:""+t,value:0})}),d.tiles.forEach((e,t)=>{var s;d.tiles[t].collider||(s=[],d.tiles[t-1]&&t%d.cols!=0&&s.push(t-1),d.tiles[t+1]&&t%d.cols!=d.cols-1&&s.push(t+1),d.tiles[t-d.cols]&&s.push(t-d.cols),d.tiles[t+d.cols]&&s.push(t+d.cols),s.forEach(e=>{1!=d.tiles[e].collider&&this.addEdge({name:t+"_"+e,from:this.nodes.get(""+t),to:this.nodes.get(""+e),value:1})}))})}getNodes(){return this.nodes}getEdges(){return this.edges}getAdjacentNodes(e){e=this.getAdjacentEdges(e).map(e=>e.to);return Array.from(new Set(e.map(e=>e.name))).map(e=>this.nodes.get(e))}getAdjacentEdges(t){return[...this.edges.values()].filter(e=>e.from===t).map(e=>e)}getAdjacentEdgesTo(t){return[...this.edges.values()].filter(e=>e.to===t).map(e=>e)}bfs(e,t){for(var s=[e],d=new Set;0<s.length;){var n=s.shift();if(d.has(n)||(d.add(n),s.push(...this.getAdjacentNodes(n))),n===t)return!0}return!1}dfs(e,t,s=new Set){s.add(e);e=this.getAdjacentNodes(e);for(const d of e){if(d===t)return!0;if(!s.has(d)&&this.dfs(d,t,s))return!0}return!1}dijkstra(t){const d=[],n=[],r=[];this.nodes.forEach(e=>n.push(e)),this.nodes.forEach(e=>r.push({node:e,distance:1/0,previous:null}));var s=r.findIndex(e=>e.node===t);if(-1===s)return[];r[s].distance=0,d.push(t),n.splice(n.indexOf(t),1);let a=t,o=this.getAdjacentEdges(a);for(let e=0;e<o.length;e++){const g=o[e];var i=r.findIndex(e=>e.node===g.to);if(-1===s)return[];r[i].distance=g.value,r[i].previous=a}for(;0<n.length;){var l;let t=1/0,s=-1;if(0<(l=r.filter(e=>n.includes(e.node)).map(e=>e.node)).length)for(let e=0;e<l.length;e++){const p=l[e];var h=r.findIndex(e=>e.node===p);r[h].distance<t&&(t=r[h].distance,s=h)}else{t=1/0,s=-1;for(let e=0;e<n.length;e++){const v=n[e];var c=r.findIndex(e=>e.node===v);r[c].distance<t&&(t=r[c].distance,s=c)}}a=r[s].node,o=(o=this.getAdjacentEdges(a)).filter(e=>!d.includes(e.from)&&!d.includes(e.to)),d.push(a),n.splice(n.indexOf(a),1);for(let e=0;e<o.length;e++){const m=o[e];var u=r.findIndex(e=>e.node===m.to),f=r.findIndex(e=>e.node===m.from),f=r[f].distance+m.value;f<r[u].distance&&(r[u].distance=f,r[u].previous=a)}}return r}shortestPath(e,t){var s=this.dijkstra(e),d=[];let n=t;for(;null!=n&&(d.push(n),null!=(n=s.find(e=>e.node==n)?.previous)););return d.reverse(),d}}export{ExcaliburGraph};