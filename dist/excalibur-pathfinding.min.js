import{TileMap}from"excalibur";class ExcaliburGraph{data;duration=0;starttime=0;endtime=0;isLoaded(){return!0}load(){return Promise.resolve()}key=!1;nodes=new Map;edges=new Map;addNode(t){this.nodes.set("number"==typeof t.id?t.id.toString():t.id,t)}addEdge(t,e=!1){this.edges.set(t.name,t),e&&(e={name:t.name+"_reverse",from:t.to,to:t.from},t.value&&Object.assign(e,{value:t.value}),this.addEdge(e))}resetGraph(){this.nodes=new Map,this.edges=new Map}addTileMap(i,o=!1){i.tiles.forEach((t,e)=>{t.collider||this.addNode({id:""+e,value:0})}),i.tiles.forEach((t,e)=>{var s;i.tiles[e].collider||(s=[],i.tiles[e-1]&&e%i.cols!=0&&s.push(e-1),i.tiles[e+1]&&e%i.cols!=i.cols-1&&s.push(e+1),i.tiles[e-i.cols]&&s.push(e-i.cols),i.tiles[e+i.cols]&&s.push(e+i.cols),o&&(i.tiles[e-i.cols-1]&&e%i.cols!=0&&s.push(e-i.cols-1),i.tiles[e-i.cols+1]&&e%i.cols!=i.cols-1&&s.push(e-i.cols+1),i.tiles[e+i.cols-1]&&e%i.cols!=0&&s.push(e+i.cols-1),i.tiles[e+i.cols+1])&&e%i.cols!=i.cols-1&&s.push(e+i.cols+1),s.forEach(t=>{1!=i.tiles[t].collider&&this.addEdge({name:e+"_"+t,from:this.nodes.get(""+e),to:this.nodes.get(""+t),value:1})}))})}getNodes(){return this.nodes}getEdges(){return this.edges}getAdjacentNodes(t){t=this.getAdjacentEdges(t).map(t=>t.to);return Array.from(new Set(t.map(t=>t.id))).map(t=>this.nodes.get("number"==typeof t?t.toString():t))}getAdjacentEdges(e){return[...this.edges.values()].filter(t=>t.from===e).map(t=>t)}getAdjacentEdgesTo(e){return[...this.edges.values()].filter(t=>t.to===e).map(t=>t)}bfs(t,e){this.starttime=performance.now();for(var s=[t],i=new Set;0<s.length;){var o=s.shift();if(i.has(o)||(i.add(o),s.push(...this.getAdjacentNodes(o))),o===e)return this.endtime=performance.now()-this.starttime,this.duration=this.endtime,!0}return this.endtime=performance.now()-this.starttime,this.duration=this.endtime,!1}dfs(t,e,s=new Set){this.starttime=performance.now();s.add(t);t=this.getAdjacentNodes(t);for(const i of t){if(i===e)return!0;if(!s.has(i)&&this.dfs(i,e,s))return this.endtime=performance.now()-this.starttime,this.duration=this.endtime,!0}return this.endtime=performance.now()-this.starttime,this.duration=this.endtime,!1}dijkstra(e){this.starttime=performance.now();const i=[],o=[],r=[];this.nodes.forEach(t=>o.push(t)),this.nodes.forEach(t=>r.push({node:t,distance:1/0,previous:null}));var s=r.findIndex(t=>t.node===e);if(-1===s)return[];r[s].distance=0,i.push(e),o.splice(o.indexOf(e),1);let n=e,d=this.getAdjacentEdges(n);for(let t=0;t<d.length;t++){const m=d[t];var h=r.findIndex(t=>t.node===m.to);if(-1===s)return[];r[h].distance=m.value,r[h].previous=n}for(;0<o.length;){var a;let e=1/0,s=-1;if(0<(a=r.filter(t=>o.includes(t.node)).map(t=>t.node)).length)for(let t=0;t<a.length;t++){const g=a[t];var l=r.findIndex(t=>t.node===g);r[l].distance<e&&(e=r[l].distance,s=l)}else{e=1/0,s=-1;for(let t=0;t<o.length;t++){const f=o[t];var c=r.findIndex(t=>t.node===f);r[c].distance<e&&(e=r[c].distance,s=c)}}if(-1===s)break;n=r[s].node,d=(d=this.getAdjacentEdges(n)).filter(t=>!i.includes(t.from)&&!i.includes(t.to)),i.push(n),o.splice(o.indexOf(n),1);for(let t=0;t<d.length;t++){const N=d[t];var p=r.findIndex(t=>t.node===N.to),u=r.findIndex(t=>t.node===N.from),u=r[u].distance+N.value;u<r[p].distance&&(r[p].distance=u,r[p].previous=n)}}return this.endtime=performance.now()-this.starttime,this.duration=this.endtime,r}shortestPath(t,e){var s=this.dijkstra(t),i=[];let o=e;for(;null!=o&&(i.push(o),null!=(o=s.find(t=>t.node==o)?.previous)););return i.reverse(),i}}class ExcaliburAstar{tilemap={cols:0,rows:0};grid=[];currentNode=null;currentIndex=0;checkedNodes=[];openNodes=[];startnode=null;endnode=null;goalReached=!1;path=[];duration=0;starttime=0;endtime=0;constructor(t){this.tilemap.cols=t instanceof TileMap?t.columns:t.cols,this.tilemap.rows=t.rows;let e=0;for(const s of t.tiles)t instanceof TileMap?this.grid.push({id:e,collider:!!s.solid,gCost:0,hCost:0,fCost:0,x:e%this.tilemap.cols,y:Math.floor(e/this.tilemap.cols),checked:!1,parent:null}):this.grid.push({id:e,collider:!!s.collider,gCost:0,hCost:0,fCost:0,x:e%this.tilemap.cols,y:Math.floor(e/this.tilemap.cols),checked:!1,parent:null}),e++}setCost(){if(null!==this.startnode&&null!==this.endnode&&0!==this.grid.length)for(const t of this.grid)t.gCost=this.getGcost(t,this.startnode),t.hCost=this.getHcost(t,this.endnode),t.fCost=this.getFcost(t)}astar(t,e,s=!1){for(this.starttime=performance.now(),this.startnode=t,this.endnode=e,this.goalReached=!1,this.checkedNodes=[],this.openNodes=[],this.setCost(),this.openNodes.push(this.startnode);0<this.openNodes.length;){this.currentNode=this.openNodes[0],this.currentIndex=0;for(const i of this.openNodes)i.fCost<this.currentNode.fCost&&(this.currentNode=i,this.currentIndex=this.openNodes.indexOf(i));if(this.openNodes.splice(this.currentIndex,1),this.checkedNodes.push(this.currentNode),this.currentNode===this.endnode){for(this.path=[];this.path.push(this.currentNode),this.currentNode=this.currentNode.parent,this.currentNode!==this.startnode;);return this.path=this.path.reverse(),this.goalReached=!0,this.endtime=performance.now(),this.duration=this.endtime-this.starttime,this.path}for(const o of this.getNeighbors(this.currentNode,s))this.checkedNodes.includes(o)||this.openNodes.includes(o)||o.collider||(o.parent=this.currentNode,this.openNodes.push(o))}return this.endtime=performance.now(),this.duration=this.endtime-this.starttime,[]}getNeighbors(t,e){var s=[],t="string"==typeof t.id?parseInt(t.id):t.id;return this.grid[t-1]&&t%this.tilemap.cols!=0&&s.push(this.grid[t-1]),this.grid[t+1]&&t%this.tilemap.cols!=this.tilemap.cols-1&&s.push(this.grid[t+1]),this.grid[t-this.tilemap.cols]&&s.push(this.grid[t-this.tilemap.cols]),this.grid[t+this.tilemap.cols]&&s.push(this.grid[t+this.tilemap.cols]),e&&(this.grid[t-this.tilemap.cols-1]&&t%this.tilemap.cols!=0&&s.push(this.grid[t-this.tilemap.cols-1]),this.grid[t-this.tilemap.cols+1]&&t%this.tilemap.cols!=this.tilemap.cols-1&&s.push(this.grid[t-this.tilemap.cols+1]),this.grid[t+this.tilemap.cols-1]&&t%this.tilemap.cols!=0&&s.push(this.grid[t+this.tilemap.cols-1]),this.grid[t+this.tilemap.cols+1])&&t%this.tilemap.cols!=this.tilemap.cols-1&&s.push(this.grid[t+this.tilemap.cols+1]),s}getNodeByIndex(t){return this.grid[t]}getNodeByCoord(t,e){return this.grid[e*this.tilemap.cols+t]}getGcost(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}getHcost(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}getFcost(t){return t.gCost+t.hCost}resetGrid(){for(const t of this.grid)t.checked=!1,t.gCost=0,t.hCost=0,t.fCost=0;this.checkedNodes=[],this.startnode=null,this.endnode=null,this.goalReached=!1,this.duration=0}}export{ExcaliburGraph,ExcaliburAstar};